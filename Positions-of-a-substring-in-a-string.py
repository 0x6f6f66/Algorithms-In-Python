Base = """Version xxxx                                             

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= 
Partial Database   
http://... 
Copyright (c) All rights reserved. 
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= 

<>

AaaI (XmaIII)                     CGGCCG 
AacI (BamHI)                      GGATCC 
AaeI (BamHI)                      GGATCC 
AagI (ClaI)                       ATCGAT 
AaqI (ApaLI)                      GTGCAC 
AarI                              NNNNNNNNGCAGGTG 
AatI (StuI)                       AGGCCT 
AatII                             GACGTC 
AauI (Bsp1407I)                   TGTACA 
AbaI (BclI)                       TGATCA 
AbeI (BbvCI)                      CCTCAGC 
AbrI (XhoI)                       CTCGAG 
AcaI (AsuII)                      TTCGAA 
AcaII (BamHI)                     GGATCC 
AcaIII (MstI)                     TGCGCA 
AcaIV (HaeIII)                    GGCC 
AccI                              GTMKAC 
AccII (FnuDII)                    CGCG 
AccIII (BspMII)                   TCCGGA 
Acc16I (MstI)                     TGCGCA 
Acc36I (BspMI)                    ACCTGCNNNN 
Acc38I (EcoRII)                   CCWGG 
Acc65I (KpnI)                     GGTACC 
Acc113I (ScaI)                    AGTACT 
AccB1I (HgiCI)                    GGYRCC 
AccB2I (HaeII)                    RGCGCY 
AccB7I (PflMI)                    CCANNNNNTGG 
AccBSI (BsrBI)                    CCGCTC 
AccEBI (BamHI)                    GGATCC 
AceI (TseI)                       GCWGC 
AceII (NheI)                      GCTAGC 
AceIII                            CAGCTCNNNNNNN 
AciI                              CCGC 
AclI                              AACGTT 
AclNI (SpeI)                      ACTAGT 
AclWI (BinI)                      GGATCNNNN"""

Base1 = """Version yyyy                                             

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= 
Partial Database   
http://... 
Copyright (c) All rights reserved. 
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= 

<>

BasI ()PflMI                      CCANNNNNTGG
BauI (BsiI)                       CACGAG
BavI (PvuII)                      CAGCTG
BavAI (PvuII)                     CAGCTG
BavAII (AsuI)                     GGNCC
BavBI (PvuII)                     CAGCTG
BavBII (AsuI)                     GGNCC
BavCI (ClaI)                      ATCGAT
BazI (ClaI)                       ATCGAT
Bba179I (BetI)                    WCCGGW
BbeI (NarI)                       GGCGCC
BbeAI (NarI)                      GGCGCC
BbfI (XhoI)                       CTCGAG
Bbf7411I (BspMII)                 TCCGGA
BbiI (PstI)                       CTGCAG
BbiII (AcyI)                      GRCGYC
BbiIII (XhoI)                     CTCGAG
Bbi24I (MluI)                     ACGCGT
BbiDI (PvuRts1I)                  CNNNNNNNNNN
BbrI (HindIII)                    AAGCTT
Bbr7I (BbvII)                     GAAGACNNNNNNN
BbrAI (HindIII)                   AAGCTT
BbrPI (PmaCI)                     CACGTG
BbrUII (SalI)                     GTCGAC
BbrUIII (PstI)                    CTGCAG
BbsI (BbvII)                      GAAGACNN
BbtI (HhaI)                       GCGC
BbuI (SphI)                       GCATGC
BbvI                              GCAGCNNNNNNNN
BbvII                             GAAGACNN
Bbv12I (HgiAI)                    GWGCWC
Bbv16II (BbvII)                   GAAGACNN
BbvAI (XmnI)                      GAANNNNTTC
BbvAII (ClaI)                     ATCGAT"""

data = "agatggcggcgctgaggggtcttgggggctctaggccggccacctactgg\
tttgcagcggagacgacgcatggggcctgcgcaataggagtacgctgcct\
gggaggcgtgactagaagcggaagtagttgtgggcgcctttgcaaccgcc\
tgggacgccgccgagtggtctgtgcaggttcgcgggtcgctggcgggggt\
cgtgagggagtgcgccgggagcggagatatggagggagatggttcagacc\
cagagcctccagatgccggggaggacagcaagtccgagaatggggagaat\
gcgcccatctactgcatctgccgcaaaccggacatcaactgcttcatgat\
cgggtgtgacaactgcaatgagtggttccatggggactgcatccggatca\
ctgagaagatggccaaggccatccgggagtggtactgtcgggagtgcaga\
gagaaagaccccaagctagagattcgctatcggcacaagaagtcacggga\
gcgggatggcaatgagcgggacagcagtgagccccgggatgagggtggag\
ggcgcaagaggcctgtccctgatccagacctgcagcgccgggcagggtca\
gggacaggggttggggccatgcttgctcggggctctgcttcgccccacaa\
atcctctccgcagcccttggtggccacacccagccagcatcaccagcagc\
agcagcagcagatcaaacggtcagcccgcatgtgtggtgagtgtgaggca\
tgtcggcgcactgaggactgtggtcactgtgatttctgtcgggacatgaa\
gaagttcgggggccccaacaagatccggcagaagtgccggctgcgccagt\
gccagctgcgggcccgggaatcgtacaagtacttcccttcctcgctctca\
ccagtgacgccctcagagtccctgccaaggccccgccggccactgcccac\
ccaacagcagccacagccatcacagaagttagggcgcatccgtgaagatg\
agggggcagtggcgtcatcaacagtcaaggagcctcctgaggctacagcc\
acacctgagccactctcagatgaggaccta"

data1 = "agatggcggcgctgaggggtcttgggggctctaggccggccacctactggtttgcagcgg\
agacgacgcatggggcctgcgcaataggagtacgctgcctgggaggcgtgactagaagcg\
gaagtagttgtgggcgcctttgcaaccgcctgggacgccgccgagtggtctgtgcaggtt\
cgcgggtcgctggcgggggtcgtgagggagtgcgccgggagcggagatatggagggagat\
ggttcagacccagagcctccagatgccggggaggacagcaagtccgagaatggggagaat\
gcgcccatctactgcatctgccgcaaaccggacatcaactgcttcatgatcgggtgtgac\
aactgcaatgagtggttccatggggactgcatccggatcactgagaagatggccaaggcc\
atccgggagtggtactgtcgggagtgcagagagaaagaccccaagctagagattcgctat\
cggcacaagaagtcacgggagcgggatggcaatgagcgggacagcagtgagccccgggat\
gagggtggagggcgcaagaggcctgtccctgatccagacctgcagcgccgggcagggtca\
gggacaggggttggggccatgcttgctcggggctctgcttcgccccacaaatcctctccg\
cagcccttggtggccacacccagccagcatcaccagcagcagcagcagcagatcaaacgg\
tcagcccgcatgtgtggtgagtgtgaggcatgtcggcgcactgaggactgtggtcactgt\
gatttctgtcgggacatgaagaagttcgggggccccaacaagatccggcagaagtgccgg\
ctgcgccagtgccagctgcgggcccgggaatcgtacaagtacttcccttcctcgctctca\
ccagtgacgccctcagagtccctgccaaggccccgccggccactgcccacccaacagcag\
ccacagccatcacagaagttagggcgcatccgtgaagatgagggggcagtggcgtcatca\
acagtcaaggagcctcctgaggctacagccacacctgagccactctcagatgaggaccta\
cctctggatcctgacctgtatcaggacttctgtgcaggggcctttgatgaccatggcctg\
ccctggatgagcgacacagaagagtccccattcctggaccccgcgctgcggaagagggca\
gtgaaagtgaagcatgtgaagcgtcgggagaagaagtctgagaagaagaaggaggagcga\
tacaagcggcatcggcagaagcagaagcacaaggataaatggaaacacccagagagggct\
gatgccaaggaccctgcgtcactgccccagtgcctggggcccggctgtgtgcgccccgcc\
cagcccagctccaagtattgctcagatgactgtggcatgaagctggcagccaaccgcatc\
tacgagatcctcccccagcgcatccagcagtggcagcagagcccttgcattgctgaagag\
cacggcaagaagctgctcgaacgcattcgccgagagcagcagagtgcccgcactcgcctt\
caggaaatggaacgccgattccatgagcttgaggccatcattctacgtgccaagcagcag\
gctgtgcgcgaggatgaggagagcaacgagggtgacagtgatgacacagacctgcagatc\
ttctgtgtttcctgtgggcaccccatcaacccacgtgttgccttgcgccacatggagcgc\
tgctacgccaagtatgagagccagacgtcctttgggtccatgtaccccacacgcattgaa\
ggggccacacgactcttctgtgatgtgtataatcctcagagcaaaacatactgtaagcgg\
ctccaggtgctgtgccccgagcactcacgggaccccaaagtgccagctgacgaggtatgc\
gggtgcccccttgtacgtgatgtctttgagctcacgggtgacttctgccgcctgcccaag\
cgccagtgcaatcgccattactgctgggagaagctgcggcgtgcggaagtggacttggag\
cgcgtgcgtgtgtggtacaagctggacgagctgtttgagcaggagcgcaatgtgcgcaca\
gccatgacaaaccgcgcgggattgctggccctgatgctgcaccagacgatccagcacgat\
cccctcactaccgacctgcgctccagtgccgaccgctgagcctcctggcccggacccctt\
acaccctgcattccagatgggggagccgcccggtgcccgtgtgtccgttcctccactcat\
ctgtttctccggttctccctgtgcccatccaccggttgaccgcccatctgcctttatcag\
agggactgtccccgtcgacatgttcagtgcctggtggggctgcggagtccactcatcctt\
gcctcctctccctgggttttgttaataaaattttgaagaaaccaaaaaaaaaaaaaaaaa\
aaaaaaaaaaaaaaaaaaaaaaaaaaa"


def get_pos(base, string, query):
    dictionary = {
        "R": ["G", "A"],
        "Y": ["C", "T"],
        "M": ["A", "C"],
        "K": ["G", "T"],
        "S": ["G", "C"],
        "W": ["A", "T"],
        "B": ["C", "G", "T"],
        "D": ["A", "G", "T"],
        "H": ["A", "C", "T"],
        "V": ["A", "C", "G"],
        "N": ["A", "C", "G", "T"]
    }
    # Format the string for correct capitalisation
    if string.islower():
        string = string.upper()

    # Format the base into an organised dictionary
    base_dict = {}
    base_split = list(item for item in base.split("<>")[1].split("\n")[2:])
    for row in base_split:
        column = row.split()
        base_dict[column[0]] = column[-1]

    if query not in base_dict:
        return "This query name does not exist in given Base"

    else:
        query_value = base_dict[query]  # We get query value from an organised base dictionary
        product_of_assembled_list_generator = product(*assemble_letters(query_value, dictionary))  # This is a generator
        substrings = concatenate(product_of_assembled_list_generator)
        check_result = check(substrings, string)  # Check if a list of substrings are in a bigger string
        if not check_result:
            return f"{query} is not in given string"
        else:
            check_result_string = ' '.join(str(num) for num in check_result)
            return check_result_string


# Method which takes a small string, a big string, and returns a list of index positions
# at which the small string appears in a big string.
def check(substrings, string):
    indexes = []
    substring_length = 0
    for substring in substrings:
        substring_length = len(substring)
        if substring in string:
            i = 0
            for _ in string:
                if string.startswith(substring, i):
                    indexes.append(i + 1)  # Task specification to output index values + 1
                    i += len(substring)  # Skip over the index of length of the string, to avoid overlapping
                else:
                    i += 1
    if indexes:
        indexes.sort()
        x = 0
        temp = []
        final = []
        while x < len(indexes) - 1:
            difference = indexes[x + 1] - indexes[x]
            x += 1
            if difference < substring_length:
                temp.append(indexes[x])
        final = [elem for elem in indexes if elem not in temp]  # Remove overlapping elements
        return final
    return indexes


# Input - String you wish to convert and a dictionary to look for special letters
# Output - A dictionary of all possible letter positions at different indexes
def assemble_letters(string, dictionary):
    letter_combinations = {}
    i = 0
    for char in string.strip():
        if char in dictionary:
            list_of_possible_letters = []
            for letter in dictionary[char]:
                list_of_possible_letters.append(letter)
            letter_combinations[i] = list_of_possible_letters
        else:
            letter_combinations[i] = char
        i += 1
    return list(letter_combinations.values())


# from Itertools | NEED TO UNDERSTAND HOW THIS WORKS, BECAUSE I DIDNT WRITE THIS CODE AND IT DOES WHAT I NEED IT TO
def product(*args, repeat=1):
    # product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy
    # product(range(2), repeat=3) --> 000 001 010 011 100 101 110 111
    pools = [tuple(pool) for pool in args] * repeat
    result = [[]]
    for pool in pools:
        result = [x + [y] for x in result for y in pool]
    for prod in result:
        yield tuple(prod)


# Input - generator
# Output - list
# Take a list of values and concatenate them all together
def concatenate(generator):
    result = []
    for item in generator:
        result.append(''.join(i for i in item))
    return result


if __name__ == '__main__':
    print(get_pos(base=Base1, string=data1, query="BbvI"))

